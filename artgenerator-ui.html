<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.11.1/ethers.umd.min.js"></script>
    <style>
        body { font-family: monospace; background: transparent; color: white; margin: 0; display: flex; height: 100vh; overflow: hidden; }
        .workspace { flex: 1; display: flex; flex-direction: column; gap: 20px; padding: 20px; }
        .input-group { display: flex; flex-direction: column; gap: 12px; }
        .prompt-input { width: 100%; background: #111; border: 1px solid #444; border-radius: 10px; padding: 18px; color: white; font-size: 1rem; box-sizing: border-box; outline: none; }
        .prompt-input:focus { border-color: #00ff80; }
        .controls-row { display: flex; gap: 12px; width: 100%; }
        select { flex: 1; background: #111; color: #00ff80; border: 1px solid #444; border-radius: 8px; padding: 10px; font-weight: bold; cursor: pointer; }
        .btn-gen { height: 50px; padding: 0 40px; background: #00ff80; color: black; border: none; border-radius: 8px; font-weight: 800; cursor: pointer; transition: 0.2s; }
        .btn-gen:hover { background: #00cc66; transform: translateY(-1px); }
        .output-view { flex: 1; background: #000; border: 1px solid #333; border-radius: 12px; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; overflow: hidden; }
        .output-img { max-width: 90%; max-height: 90%; display: none; border-radius: 8px; }
        .status-txt { color: #888; text-align: center; padding: 20px; font-size: 0.9rem; }
        .history-sidebar { width: 280px; border-left: 1px solid #333; background: rgba(0,0,0,0.3); padding: 20px; display: flex; flex-direction: column; }
        #history-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; overflow-y: auto; }
        .gallery-item { position: relative; aspect-ratio: 1/1; background: #080808; border: 1px solid #444; border-radius: 8px; cursor: pointer; overflow: hidden; }
        .gallery-item img { width: 100%; height: 100%; object-fit: cover; }
        .gallery-item .digest { position: absolute; bottom: 0; width: 100%; background: rgba(0,0,0,0.8); color: #00ff80; font-size: 8px; text-align: center; padding: 4px 0; }
    </style>
</head>
<body>

<div class="workspace">
    <div class="input-group">
        <input type="text" id="prompt-input" class="prompt-input" placeholder="Type your prompt and hit generate...">
        <div class="controls-row">
            <select id="model-select">
                <option value="0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef">SDXL-Turbo</option>
                <option value="0x8888888888888888888888888888888888888888888888888888888888888888">Flux.1-Lightning</option>
                <option value="0x9999999999999999999999999999999999999999999999999999999999999999">Stable Diffusion 3</option>
            </select>
            <button id="gen-button" class="btn-gen" onclick="generate()">GENERATE</button>
        </div>
    </div>
    <div class="output-view">
        <p id="status" class="status-txt">Ready for Inference Command...</p>
        <img id="result-img" class="output-img">
    </div>
</div>

<div class="history-sidebar">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h3 style="font-size: 0.7rem; color: #00ff80; font-weight: 900; margin:0; letter-spacing: 1px;">ON-CHAIN REVEALS</h3>
        <button onclick="initHistory()" style="background: #333; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 0.6rem; cursor: pointer;">SYNC â†»</button>
    </div>
    <div id="history-grid"></div>
</div>

<script>
const CONFIG = { AIVM_ADDR: "0xbcA38515887Dc3Ca163398C0Ef7bF02dd156D8FB" };
const modelHash = "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef";
    
// Universal ABI covering both potential versions of the contract
const ABI = [
    "function generateArt(string prompt, bytes32 modelDigest) public payable",
    "function generateArt(string prompt) public payable",
    "event ArtGenerated(address indexed user, string prompt, bytes32 modelDigest, uint256 fee)",
    "event ArtGenerated(address indexed user, string prompt, uint256 timestamp)"
];

async function generate() {
    const promptInput = document.getElementById('prompt-input');
    const modelSelect = document.getElementById('model-select');
    const statusEl = document.getElementById('status');
    const imgEl = document.getElementById('result-img');
    const btn = document.getElementById('gen-button');

    if (!promptInput.value.trim()) {
        statusEl.innerText = "Please enter a prompt first.";
        return;
    }

    try {
        // UI State: Loading
        btn.disabled = true;
        statusEl.style.display = "block";
        imgEl.style.display = "none";
        statusEl.innerText = "Requesting signature... Please check MetaMask.";

        const provider = new ethers.BrowserProvider(window.ethereum);
        const signer = await provider.getSigner();
        const contract = new ethers.Contract(CONFIG.AIVM_ADDR, ABI, signer);

        // Transaction config: 0.1 LCAI fee + a safe gas buffer
        const txOptions = { 
            value: ethers.parseEther("0.1"), 
            gasLimit: 500000 
        };

        let tx;
        try {
            // Attempt 1: New Contract Standard (Prompt + Model Digest)
            tx = await contract.generateArt(promptInput.value, modelSelect.value, txOptions);
        } catch (contractErr) {
            console.warn("2-argument call failed, falling back to 1-argument...", contractErr);
            // Attempt 2: Older Contract Standard (Prompt only)
            tx = await contract.generateArt(promptInput.value, txOptions);
        }

        statusEl.innerText = "Transaction broadcasted! Waiting for Lightchain block confirmation...";
        
        // Wait for the transaction to be mined
        await tx.wait();
        
        statusEl.innerText = "Inference anchored. Loading visual payload...";

        // Render the image securely
        const safePrompt = encodeURIComponent(promptInput.value.trim());
        imgEl.src = `https://image.pollinations.ai/prompt/${safePrompt}?nologo=true&seed=${Date.now()}`;
        
        imgEl.onload = () => {
            statusEl.style.display = "none";
            imgEl.style.display = "block";
        };

        // Automatically refresh the sidebar history after a short delay
        setTimeout(initHistory, 3000);

    } catch (error) {
        console.error("Generate Error:", error);
        // Extract the most human-readable error message possible
        const errorMessage = error.reason || error.message.split('(')[0] || "Transaction failed.";
        statusEl.innerText = `Error: ${errorMessage}`;
    } finally {
        // Restore UI state
        btn.disabled = false;
    }
}

async function initHistory() {
    const grid = document.getElementById('history-grid');
    
    try {
        const provider = new ethers.BrowserProvider(window.ethereum);
        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
        
        if (!accounts || accounts.length === 0) {
            grid.innerHTML = "<div style='color:#888; font-size:0.8rem; grid-column:span 2;'>Wallet not connected.</div>";
            return;
        }

        const userAddress = accounts[0];
        const contract = new ethers.Contract(CONFIG.AIVM_ADDR, ABI, provider);
        
        // Create a filter for the 'ArtGenerated' event specific to the connected wallet
        const filter = contract.filters.ArtGenerated(userAddress);
        
        // Scan the last 50,000 blocks to ensure we catch recent history without timing out the RPC
        const events = await contract.queryFilter(filter, -50000); 

        if (events.length === 0) {
            grid.innerHTML = "<div style='color:#555; font-size:0.8rem; grid-column:span 2;'>No on-chain history found in recent blocks.</div>";
            return;
        }

        // Map events to our history array with safe parsing
        history = events.map(e => {
            // Safely extract the prompt whether it's accessed by name or index
            const promptVal = e.args.prompt || e.args[1] || "Unknown Prompt";
            // Safely extract the digest, or provide a default if it doesn't exist in this event version
            const digestVal = e.args.modelDigest ? e.args.modelDigest.slice(0, 10) : "Default";

            return {
                prompt: promptVal,
                digest: digestVal,
                // Tie the image seed to the block number so the history image is consistent
                url: `https://image.pollinations.ai/prompt/${encodeURIComponent(promptVal.trim())}?nologo=true&seed=${e.blockNumber}`
            };
        }).reverse(); // Reverse to show newest first

        renderHistory();

    } catch (error) {
        console.error("History Sync Error:", error);
        grid.innerHTML = "<div style='color:red; font-size:0.8rem; grid-column:span 2;'>Sync failed. The network might be congested.</div>";
    }
}
function loadHistory(prompt, url) {
    document.getElementById('prompt-input').value = prompt;
    const imgEl = document.getElementById('result-img');
    const statusEl = document.getElementById('status');
    statusEl.style.display = "none";
    imgEl.style.display = "block";
    imgEl.src = url;
}

window.addEventListener('load', () => { if (window.ethereum) initHistory(); });
</script>
</body>
</html>
